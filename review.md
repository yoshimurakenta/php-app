# PHP App ① レビュー

## 全般

### 以下のaタグのリンクを押下した際にedit.phpの$_GETにどんな値が格納されるか説明してください。

```html
<a href="edit.php?todo_id=123&todo_content=焼肉">更新</a>
```
リンクを押下してedit.phpに遷移するとURLクエリパラメータで指定されたデータが下記のように連想配列として格納される。
 
 $_GET = 
  [
    'todo_id' => '123'
    'todo_content' => '焼肉'
  ]

これによってedit.phpでこれらの値を用いて指定されたIDのToDoの編集画面を表示したり編集処理を行ったりできる。

### 以下のフォームの送信ボタンを押下した際にstore.phpの$_POSTにどんな値が格納されるか説明してください。

```html
<form action="store.php" method="post">
    <input type="text" name="id" value="123">
    <textarea　name="content">焼肉</textarea>
    <button type="submit">送信</button>
</form>
```

$postの値には連想配列が格納されている。
name属性がキーでvalue属性がバリューとなっており、
今回の場合は、
$post = [
  'id' => '123'
  'content' => '焼肉'
]
という連想配列が格納されている。

### `require_once()` は何のために記述しているか説明してください。
外部ファイルの読み込みをするための記述でファイルがすでに読み込まれているかどうかをphpがチェックし、
一度読み込んだファイルは２回目以降読み込まないようにする。
同じようなもので「require()」というものがある。
require_onceを利用する場合は、処理時に同じファイルが複数回読み込まれ、関数の再定義や変数の再代入の可能性を回避する目的で利用をする。
また、require_once()を使用して別ファイルを読み込む理由としてコードの再利用性を高め、メンテナンスを容易にしてアプリケーションの構造を整理するため。

1.コードの再利用性
　データベースの接続など複数のページで共通して使う機能を一つのファイルにまとめてrequire_once()を使って読み込むことでコードを再利用することができる。
  こうすることで同じコードを複数のファイルにコピペする必要もない。

2.メンテナンスの容易さ
  ・一つのファイルにまとめておくことで変更が必要な時にそのファイルだけを修正すれば全ての関連のファイルに反映される。これによりメンテナンスが容易になる。
  ・同じコードを複数の場所にコピーしていた場合、変更の際にどこか一箇所を修正し忘れるリスクがある。require_once()を使うとコードが一箇所にまとめられているためそのリスクが軽減され
    バグが減る。

3.アプリケーションの構造の整理
  ・プロジェクトが大規模になっていくと全てのコードを一つに書くのは非効率であり、理解しにくくなってしまう。機能ごとにファイルをわけ、それらをrequire_onceで読みこむことで
    アプリケーションをモジュール化し整理された構造にすることができる。
  ・各機能ごとにファイルを分けてそれぞれの役割に応じたファイルを読み込むことでコードの可読性が向上する。

4.エラー防止
  同じファイルを２度読み込むことがないため、複数回同じファイルを読み込むエラーが防止できる。


### `savePostedData($post)`は何をしているか説明してください。
どのページからフォームが送信されたかをチェックして対応するデータベースの処理を実行する。

```PHP

function savePostedData($post)
{
    $path = getRefererPath();
    switch ($path) {
        case '/new.php':
            createTodoData($post['content']);
            break;
        case '/edit.php':
            updateTodoData($post);
            break;
        default:
            break;
    }
}

function getRefererPath()
{
    $urlArray = parse_url($_SERVER['HTTP_REFERER']);
    return $urlArray['path'];
}

```
リクエスト元のURLを文字列で取得してそのパスを返すgetRefererPath()関数を定義し、
それを savePostedData()関数で呼び出してそのリクエスト元のパスで
条件を分岐して処理を振り分けている。

getRefererPath()関数でフォームがどこから送信されたのかを取得し、それを savePostedData()関数で呼び出して
新規作成ページからPOSTされたなら、createTodoData関数 を実行（INSERT処理）
編集ページからPOSTされたなら、updateTodoData関数 を実行（UPDATE処理）
をするというように処理の振り分けを行っている。


### `header('location: ./index.php')`は何をしているか説明してください。
header関数を使い、リダイレクト先を指定することができる。

header関数は 
header ('Location : 遷移先のURL')で指定することができ、
URLは絶対パス（http:）、相対パス(./)のどちらでも指定することができる。


### `getRefererPath()`は何をしているか説明してください。
フォームやリンクがどのページから送信されたのかを把握するために送信元ページのパスを取得しそれを返す関数です。
HTTPリクエストの送信元となるページのURL（リファラ）のパス部分を取得して返す役割を持っています。

```PHP
function getRefererPath()
{
    $urlArray = parse_url($_SERVER['HTTP_REFERER']);　//ここでリファラのURLを解析して配列に変換をしている。
    // 具体的には例えば新規作成ページからフォームが送信された場合、
    // $_SERVER['HTTP_REFERER'] は http://example.com/new.php というURLになることがあり
    // parse_url() でURLを解析をし、URLを構成する要素（スキーム、ホスト、パス、クエリなど）を配列に分解する。
    // すると下記のような形の配列となる。
    // $urlArray = parse_url('http://example.com/new.php');
    // 結果:
    $urlArray = [
      'scheme' => 'http',
      'host' => 'example.com',
      'path' => '/new.php'
      ];
    return $urlArray['path'];
    その配列のパスをリターンで返している。
}

```

この関数を`savePostedData()関数で呼び出すことでそれぞれのページによって異なる処理を行うことができる。


### `connectPdo()` の返り値は何か、またこの記述は何をするための記述か説明してください。

connectPdo()の返り値はpdoクラスのインスタンスです。
DBに接続をしてSQLクエリの実行やトランザクションの管理ができるようになる。
データベース接続を標準化し、エラーハンドリングを統一し、コードのメンテナンス性やセキュリティを向上させるために記述している。
具体的には、
1.コードの再利用性を高める。
  データベース接続を一つにまとめることで複数のスクリプトで同じ接続設定を使い回すことができる。
  接続設定を変更する際もconnectPdo()の定義を変更するだけで済むのでメンテナンスも容易になる。

2.コードの簡素化
  データベース接続の処理を各スクリプトで繰り返し記述する必要がなくなる。このため、簡潔で読みやすくなる。

3.セキュリティの向上
  接続情報を関数内に記述することでセキュリティリスクを低減できる。
  また、接続情報を直接公開することなく関数を呼び出すことでプログラム全体のセキュリティを保つことができる。

4.エラーハンドリングの統一
  関数内で例外処理を行うことで接続エラーが発生した時の対応を統一的に処理できる。


### `try catch`とは何か説明してください。
プログラムのエラーに対して処理を行う例外処理のこと。
try{}の中に例外の発生する可能性がある処理を書き、catch(Exception $e){}の中に例外が発生した場合に行う処理を書く。

try
{
　例外が発生する可能性のあるコード
} catch(Exception $e) {
  例外が発生した場合に行う処理
}
例外処理の必要な場合
・名前を指定してファイルを開く処理（指定した名前ファイルが存在しない時に例外が発生する）
・DBの値を操作する時
（DBのサーバーが止まっていると例外が発生する）
・渡された引数を使って割り算をする処理
（０で割った時に例外が発生する）

### Pdoクラスをインスタンス化する際に`try catch`が必要な理由を説明してください。
PDOはDBとのやりとりをするメソッドが多くあるクラスなのでDBの値を操作する際にDBサーバーが止まっていると例外が発生をするためその時の例外に対しての処理を適切にし、
アプリケーションの予期せぬクラッシュを避けるため。
PDOExceptionは、PHPの組み込みクラスExceptionを継承しており、PDOを使ったデータベース操作中に発生するエラーを扱うための例外クラスです。
データベース接続やSQL操作中のエラーに対して、適切なエラーハンドリングを実装するために利用され、try-catch 構文を使用してこの例外をキャッチし、エラーメッセージやエラーコードを利用してデバッグやエラーメッセージの表示をすることが可能。
PDOExceptionがthrowされるのはnew PDO()の呼び出しの時にデータベース接続に失敗した時でnew PDO()を呼び出すときに発生する可能性のあるデータベース接続エラーを適切に処理するため。

具体的なエラーの例として、
1.データベースの接続に失敗
　・DSNが間違っている場合
　・データベースが存在しない、またはアクセスできない場合
　・データベースサーバーがダウンしている場合

2.認証エラー
　・提供されたDB_USERまたはDB_PASSWORDが正しくない場合
　・ユーザーに必要な権限がない場合

3.PDOの初期化エラー
　・PDO自体の設定や拡張モジュールが正しくロードされていない場合



## 新規作成

### `createTodoData($post)`は何をしているか説明してください。
含まれているデータをデータベースに保存をする処理を行っている。
例えば今回の
createTodoData($post['content']) は、$post['content'] 
に含まれるデータをデータベースに保存するための処理を行い、
それをcreateData($post)に返している。

## 一覧

### `getTodoList()`の返り値について説明してください。
connection.phpで実装したgetAllRecords関数の処理を呼び出し処理を実行し、その結果が返り値として返る。
つまり、登録したデータをDBから全件取得し、その結果を返り値として返している。


```php

//function.php

<?php
require_once('connection.php');

function createData($post)
{
  createTodoData($post['content']);
}

function getTodoList()
{
    return getAllRecords();
}

//connection.php

function getAllRecords()
{
    $dbh = connectPdo();
    $sql = 'SELECT * FROM todos WHERE deleted_at IS NULL';
    return $dbh->query($sql)->fetchAll();
}

```
getAllRecords関数は$sqlでtodosテーブルから、削除されていないレコードを全件取得する という内容のSQL文を格納しており、
それを$dbh->query($sql)でDBに対して作成したSQL文を実行しfetchAll()で実行結果を全件配列で取得、そしてその結果をreturnしている。
getTodoListではそのgetAllRecordsの関数を処理を呼び出し実行しているのでgetAllRecords関数が実行される結果がgetTodoListの返り値となり
データベースのレコードが格納された配列が返される。

### `<?= ?>`は何の省略形か説明してください。

echoの省略形をしたもの。
<?php echo 'Hello World!';?>
<?= 'Hello World!'?>
この２つは同じ意味を持つものでHTMLと混在してPHPの処理を書くときに使用する。

## 更新

### `getSelectedTodo($_GET['id'])`の返り値は何か、またなぜ`$_GET['id']` を引数に渡すのか説明してください。
データベースから取得された特定のTODOデータを連想配列で返している。
例えば以下のような連想配列が返される。
[
  'id' => 1,
  'content' => 'TEST1',
  'create_at' => '2024-09-17 12:00:00',
  'update_at' => '2024-09-17 14:00:00'
]

なぜ$_GET['id']を引数に渡すのか
URLクエリパラメータで渡されたidを$_GET['id']で取得し、そのIDを引数として呼び出し
データベースから該当するTODO項目を取得するため。
簡単いうと特定のToDo項目をデータベースから取得するために、その項目を識別する一意のIDを関数に渡す必要があるから。

### `updateTodoData($post)`は何をしているか説明してください。
「$post」に格納されている配列から受け取ったcontentとidを使い、データベース上で特定のToDo項目の内容を更新する処理を行っている。
この関数を通じて、ユーザーがフォームから送信した新しい内容にToDoリストの項目が更新される。


## 削除

### `deleteTodoData($id)`は何をしているか説明してください。
指定されたidを持つToDoアイテムを論理削除するための関数です。
「$id」には削除したいtodosテーブルのレコードidを受け取っている。

例えばdeleteTodoData($id)に５が渡されると

```PHP
function deleteTodoData($id)　//ここで$idに５という値が渡される
{
    $dbh = connectPdo(); // データベース接続
    $now = date('Y-m-d H:i:s'); // 現在の日時を取得する
    $sql = 'UPDATE todos SET deleted_at = "' . $now . '" WHERE id = ' . $id; // SQL文を作成
    // $sql = 'UPDATE todos SET deleted_at = '2024-09-17-12:00:00' WHERE id = 5'; 上のSQLが実行されるとこのように展開される
    $dbh->query($sql); // SQL文を実行
}
```
todos テーブルのidが５のレコードの deleted_at カラムが 2024-09-17 12:00:00に更新される。
この結果そのレコードは論理的には削除されたと見なされる。



### `deleted_at`を現在時刻で更新すると一覧画面からToDoが非表示になる理由を説明してください。

deleted_atカラムが論理削除のフラグとして機能をしているから。

一覧画面の表示の条件として
getAllRecords()関数で$sql = 'SELECT * FROM todos WHERE deleted_at IS NULL';
とあり、これはdeleted_atカラムの値がNULLの値を取得するという条件で記述をしています。
つまり、deleted_atカラムに日時が設定されているレコードはこのクエリの結果に含まれないため一覧画面からToDoが非表示になる。

1.ToDoが作成
　deleted_atカラムはNULLなので一覧画面に表示される。
2.ToDoが削除されると
　deleted_atカラムが現在の日時で更新される。例えば'2024-09-17-12:00:00'と設定される。
3.一覧画面に表示されるクエリが実行されると
　deleted_at IS NULLという条件により、deleted_atに日時設定されているレコードは除外されるためこのToDoは一覧画面に表示される。


### 今回のように実際のデータを削除せずに非表示にすることで削除されたように扱うことを〇〇削除というか。

論理削除

### 実際にデータを削除することを〇〇削除というか。

物理削除

### 前問のそれぞれの削除のメリット・デメリットについて説明してください。

論理削除のメリット
1.データの復元が容易にできる。
　論理削除ではデータを完全に削除せずに削除フラグやdeleted_atのカラムで削除済みであることをマークするためdeleted_atの値をNULLに戻すことでデータが復元される。
2.データの履歴保持
　削除されたデータが保持されされ続けるため過去のデータを参照することが可能で、データの変更履歴や過去のユーザーの行動を記録しておける。
3.誤削除の防止
　誤って重要なデータを削除してしまうリスクを軽減させる。

論理削除のデメリット
1.データベースの肥大化
　レコードが物理的に削除されないため、削除されたデータもデータベースに残る。その結果データベースのサイズが大きくなりパフォーマンスに悪影響を及ぼす可能性がある。
2.クエリの複雑化
　全てのSELECT文で「論理削除されたデータを除外する」ためにWHERE deleted_at IS NULLの条件を加える必要があり、クエリが複雑になる。
3.一意性制約への影響
  論理削除したデータが残っているとユニーク制約（一意性制約）に影響を及ぼす可能性がある。ユーザー名などでユニークでなければならない場合に論理削除したデータが存在していることで
  同じ名前が使えないという問題が発生することがある。

物理削除のメリット
1.データベースの肥大化を防げる
　物理削除ではデータを完全に削除するため、不要なデータが蓄積することなくデータベースのサイズを抑えることができる。
　これによりデータベースの長期的なパフォーマンスの維持につながる
2.クエリがシンプルになる
　削除されたデータが存在しないため、WHERE deleted_at IS NULLのような条件を追加する必要がない。クエリが簡単になることで処理が高速にことが多い。
3.ユニーク制約に影響がない
　削除されたデータは完全に消えるため、ユニーク制約を持つフィールドに対して新しいデータを挿入する際に、重複エラーが発生することがない。

物理削除のデメリット
1.データの復元ができない
　一度物理削除したデータは完全に削除されるため、削除後に誤ってデータを削除してしまった場合や、後から必要になった場合に簡単に
　復元をすることはできない。バックアップ等がない限りデータの復元はかなり困難になる。
2.監査や履歴追跡ができない
　データそのものが削除されてしまうため誰がいつどのデータを削除したのかなどの履歴を残すことができない。
　監査の必要なシステムではデータの削除履歴を管理できないのは大きなデメリットになる。
3.法的問題に対処しにくい
　企業や組織によっては特定のデータを一定期間保持することが法律で義務付けられている場合がある。物理削除ではデータを完全に消去するため必要なデータを保持できない可能性があり
　法的リスクを伴うことがある。

論理削除と物理削除の使い分けは
物理削除は、パフォーマンス重視や完全に不要なデータを削除したい場合に最適になる。
論理削除は、データの復元や監査、法的要件がある場合に適している。
システム要件やデータの性質に応じて、適切な削除方法を選ぶことが重要になる。
論理削除と物理削除は混合して使用する場合もある。